# -*- coding: utf-8 -*-
"""Original.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/150ZYYTl0rg-a0D-7Xz4HOs8EttKM7QFW
"""

!pip uninstall -y pydantic thinc spacy langchain langchain-core
!pip install pydantic==2.9.2 thinc==8.3.6 spacy==3.8.5 langchain==0.3.23 langchain-core==0.3.51
!pip install numpy==1.24.3 pandas==2.2.2 scikit-learn==1.3.2 scipy==1.11.4 imbalanced-learn==0.11.0 xgboost lightgbm

import numpy as np
import pandas as pd
print(np.__version__)
print(pd.__version__)
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, RandomizedSearchCV, StratifiedKFold
from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.decomposition import PCA
from sklearn.feature_selection import SelectKBest, mutual_info_classif
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report, roc_curve, auc
from sklearn.preprocessing import StandardScaler
from imblearn.over_sampling import SMOTE
import gc

data_path = 'ransomware_detection_updated.csv'  # Path to generated dataset
df = pd.read_csv(data_path)
df

df = df.select_dtypes(include=['number'])
df

df.dropna(inplace=True)
df

X = df.drop('Ransomware Label', axis=1)
y = df['Ransomware Label']
X_selected = SelectKBest(mutual_info_classif, k=min(25, X.shape[1])).fit_transform(X, y)
X

y

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_selected)

smote = SMOTE(sampling_strategy=0.8, random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_scaled, y)

n_pca_components = min(10, X_resampled.shape[1])  # Adjust components dynamically
pca = PCA(n_components=n_pca_components)
X_pca = pca.fit_transform(X_resampled)

X_train, X_test, y_train, y_test = train_test_split(X_pca, y_resampled, test_size=0.25, stratify=y_resampled, random_state=42)

grid_rf = {'n_estimators': [200, 300], 'max_depth': [15, 20], 'min_samples_split': [2, 5]}
grid_xgb = {'n_estimators': [100, 300], 'learning_rate': [0.05, 0.1], 'max_depth': [6, 8]}
grid_lgbm = {'n_estimators': [100, 300], 'learning_rate': [0.05, 0.1]}

rf = RandomizedSearchCV(RandomForestClassifier(random_state=42), grid_rf, cv=3, n_jobs=-1, n_iter=4, random_state=42)
xgb = RandomizedSearchCV(XGBClassifier(random_state=42, tree_method='hist'), grid_xgb, cv=3, n_jobs=-1, n_iter=4, random_state=42)
lgbm = RandomizedSearchCV(LGBMClassifier(random_state=42), grid_lgbm, cv=3, n_jobs=-1, n_iter=4, random_state=42)

models = {
    'Random Forest': rf,
    'XGBoost': xgb,
    'LightGBM': lgbm,
    'Logistic Regression': LogisticRegression(random_state=42, max_iter=500)
}

results = {}
for name, model in models.items():
    print(f"Training {name}...")
    trained_model = model.fit(X_train, y_train)
    best_model = trained_model.best_estimator_ if isinstance(trained_model, RandomizedSearchCV) else trained_model
    y_pred = best_model.predict(X_test)

    results[name] = {
        'Accuracy': accuracy_score(y_test, y_pred),
        'Confusion Matrix': confusion_matrix(y_test, y_pred),
        'Classification Report': classification_report(y_test, y_pred)
    }
    print(f"Best parameters for {name}: {trained_model.best_params_ if isinstance(trained_model, RandomizedSearchCV) else 'N/A'}")

del X_resampled, y_resampled, X_scaled, X_selected
gc.collect()

for name, result in results.items():
    print(f"{name} Results:")
    print(f"Accuracy: {result['Accuracy']:.2f}")
    print("\nConfusion Matrix:")
    print(result['Confusion Matrix'])
    print("\nClassification Report:")
    print(result['Classification Report'])

plt.figure(figsize=(8, 5))
plt.bar(results.keys(), [res['Accuracy'] for res in results.values()], color=['skyblue', 'lightgreen', 'orange', 'pink'])
plt.ylim(0.7, 1.0)
plt.title('Model Accuracy Comparison')
plt.xlabel('Models')
plt.ylabel('Accuracy')
plt.show()

plt.figure(figsize=(20, 6))
for i, (name, result) in enumerate(results.items(), 1):
    plt.subplot(1, 4, i)
    sns.heatmap(result['Confusion Matrix'], annot=True, fmt='d', cmap='coolwarm')
    plt.title(f'{name} Confusion Matrix')
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 8))
for name, model in models.items():
    best_model = model.best_estimator_ if isinstance(model, RandomizedSearchCV) else model
    if hasattr(best_model, 'predict_proba'):
        y_pred_proba = best_model.predict_proba(X_test)[:, 1]
        fpr, tpr, _ = roc_curve(y_test, y_pred_proba)
        roc_auc = auc(fpr, tpr)
        plt.plot(fpr, tpr, label=f'{name} (AUC = {roc_auc:.2f})')

plt.plot([0, 1], [0, 1], 'k--', lw=2)
plt.title('ROC Curve Comparison')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.legend(loc='lower right')
plt.grid()
plt.show()